<!DOCTYPE html>
<html>
  <head>
    
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
  <link rel="manifest" href="/favicons/site.webmanifest">

  
  
  <title>DEVLOG W | 자바스크립트의 비교 연산자는 왜 이럴까?</title>

  
  <link rel="stylesheet" type="text/css" href="/sass/layout.min.981eba9c7afc1cd03a5f0ea93107e171972b8bc5788b91f11d9d444c9f71e9b6.css">
</head>

  
  <link rel="stylesheet" type="text/css" href="/sass/single.min.08b0d1f8d90a40452781830f3ab8c438cf6d688490132424f465dfd7caa89429.css">

  </head>
<body>
  <header>
    <div id="header-wrapper">
  <a href="/"><h1 id="header-title">DEVLOG W</h1></a>

  <menu id="header-menu">
    
      <li class="header-menu-item">
        
        

        <a href="/" target="_self">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Pro 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"/></svg>
        </a>
      </li>
      <li class="header-menu-item">
        
        

        <a href="https://github.com/wcho21" target="_blank">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Pro 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
        </a>
      </li>
  </menu>
</div>
  </header>
  <main>
    
  <article id="article">
    <h1 id="article-heading">자바스크립트의 비교 연산자는 왜 이럴까?</h1>
    <p id="article-date">2022-09-25</p>

    <div id="article-content">
      <p>예전에, 자바스크립트의 이상한 점들을 다루는 어떤 영상을 본 적이 있었다.
그 중에 호기심이 든 것은 이것이었다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#ff79c6">null</span> <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0</span>; <span style="color:#6272a4">// true
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">null</span> <span style="color:#ff79c6">&lt;=</span> <span style="color:#bd93f9">0</span>; <span style="color:#6272a4">// true
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">null</span> <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>; <span style="color:#6272a4">// false (!)
</span></span></span></code></pre></div><p>이럴 수가. <code>0</code> 이상이면서 <code>0</code>이하인데, <code>0</code>은 아니라고 한다!
자바스크립트로 엄청난 수학적 발견을 한 것 같다.</p>
<p>한편, 이는 다음과 같은 질문으로 바꿀 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#ff79c6">null</span> <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0</span>; <span style="color:#6272a4">// true
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>(<span style="color:#ff79c6">null</span> <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">||</span> (<span style="color:#ff79c6">null</span> <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>); <span style="color:#6272a4">// false
</span></span></span></code></pre></div><p>왜 자바스크립트는 이런 결과를 보이는 것일까?
질문을 바꾸자면, <code>==</code> 연산과 <code>&gt;=</code> 연산은 무엇이 다른가?</p>
<h2 id="tldr">TL;DR</h2>
<ol>
<li>
<p><code>null == 0</code> 연산은 적절한 비교 방식을 찾지 못하고 정의에 따라 <code>false</code> 값을 리턴한다.</p>
</li>
<li>
<p><code>null &gt;= 0</code> 연산은 <code>null</code> 값을 숫자 타입으로 변환하여 <code>0</code> 값으로 바꾸기 때문에 <code>true</code> 값을 리턴한다.</p>
</li>
<li>
<p>위 내용은 ECMAScript 스펙에 표준화 되어있다.</p>
</li>
</ol>
<h2 id="null-값이-0-값과-같지-않은-이유"><code>null</code> 값이 <code>0</code> 값과 같지 않은 이유</h2>
<p>먼저 다음 경우를 살펴보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#ff79c6">null</span> <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>; <span style="color:#6272a4">// false
</span></span></span></code></pre></div><h3 id="islooselyequal-알고리즘"><code>IsLooselyEqual</code> 알고리즘</h3>
<p><a href="https://262.ecma-international.org/13.0/#sec-equality-operators-runtime-semantics-evaluation">ECMA 스펙</a>에 따르면, <code>==</code> 연산을 수행할 때, <code>IsLooselyEqual</code> 알고리즘을 수행하게 된다고 한다.
이 알고리즘의 <a href="https://262.ecma-international.org/13.0/#sec-islooselyequal">스펙</a>에 따르면, <code>x == y</code> 연산은 다음을 수행한다.</p>
<ol>
<li>양쪽 타입이 같으면, <code>IsStrictlyEqual(x, y)</code> 알고리즘의 결과를 리턴한다.</li>
<li>한쪽이 <code>null</code> 값이고 다른쪽이 <code>undefined</code> 값이면 <code>true</code> 값을 리턴한다.</li>
<li>그렇지 않으면:
<ol>
<li><code>x</code> 타입이 숫자이면, &hellip; (생략)</li>
<li><code>x</code> 타입이 문자열이면, &hellip; (생략)</li>
<li><code>x</code> 타입이 <code>BigInt</code>이면, &hellip; (생략)</li>
<li><code>x</code> 타입이 불리언이면, &hellip; (생략)</li>
<li><code>x</code> 타입이 객체이면, &hellip; (생략)</li>
</ol>
</li>
<li>그 외의 경우, <code>false</code> 값을 리턴한다.</li>
</ol>
<p>(위 단계는 재구성한 부분이 있으므로, 정확한 알고리즘은 직접 스펙을 참고하길 바란다.)</p>
<h3 id="null-값-비교"><code>null</code> 값 비교</h3>
<p>한쪽이 <code>null</code> 값일 때 <code>true</code> 값이 리턴되는 경우는, 다른 쪽이 <code>null</code> 값이거나 <code>undefined</code> 값인 경우 뿐이다.</p>
<p>따라서 <code>null == 0</code> 비교는 마지막 스텝에서 일컫는 &lsquo;그 외의 경우&rsquo;에 의해 <code>false</code> 값이 된다.
굳이 이름에 이유를 붙이자면, 비교 실패로 인한 <code>false</code> 값 리턴이라고 하면 적절할 지 모르겠다.</p>
<p>덧붙여 위 알고리즘에서 두 가지 사실을 알 수 있다.</p>
<ul>
<li>
<p><code>null == undefined</code> 비교는 알고리즘 상 <code>true</code> 값으로 정의되어있다.</p>
</li>
<li>
<p>양쪽이 <code>null</code> 값으로 같을 때, 첫 번째 스텝에 의해 <code>IsStrictlyEqual</code> 알고리즘을 수행한다.
이는 <code>===</code> 비교 연산이 수행하는 알고리즘이다.
즉 <code>null == null</code> 연산이나 <code>null === null</code> 연산은 사실상 같은 비교 알고리즘을 갖는다.</p>
</li>
</ul>
<h2 id="null-값이-0-값보다-같거나-큰-이유"><code>null</code> 값이 <code>0</code> 값보다 같거나 큰 이유</h2>
<p>이제 다음 경우가 남았다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#ff79c6">null</span> <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0</span>; <span style="color:#6272a4">// true
</span></span></span></code></pre></div><p>이 경우는 스펙을 읽기가 살짝 복잡할 수도 있다. 사용되는 알고리즘이 여럿이기 때문이다.</p>
<h3 id="islessthan-알고리즘"><code>IsLessThan</code> 알고리즘</h3>
<p><a href="https://262.ecma-international.org/13.0/#sec-relational-operators">ECMA 스펙</a>에 따르면, <code>&gt;=</code> 연산은 <code>IsLessThan</code> 알고리즘의 결과 값을 이용한다.
여기서, <code>&gt;=</code> 연산은 &lsquo;같거나 큰&rsquo; 연산이다.
<code>IsLessThan</code> 알고리즘은 &lsquo;작을 때&rsquo; 참 값을 리턴할 것이므로, 원하는 결과의 반대란 사실을 참고하자.</p>
<p><code>IsLessThan(x, y)</code> 알고리즘은 <a href="https://262.ecma-international.org/13.0/#sec-islessthan">스펙</a>에 따르면 다음과 같은 스텝을 따른다.</p>
<ol>
<li>양쪽 값을 원시 타입으로 변환한다.</li>
<li>(&hellip; 중략 &hellip;)</li>
<li><code>x</code>, <code>y</code> 값에 <code>ToNumeric</code> 알고리즘을 수행하고 그 결과를 각각 <code>nx</code>, <code>ny</code>라고 한다.</li>
<li><code>nx</code>, <code>ny</code>의 타입이 같을 때
<ol>
<li><code>nx</code>의 타입이 숫자라면, <code>Number::lessThan(nx, ny)</code> 알고리즘의 결과를 리턴한다.</li>
<li><code>nx</code>의 타입이 BigInt라면, <code>BigInt::lessThan(nx, ny)</code> 알고리즘의 결과를 리턴한다.</li>
</ol>
</li>
<li>한쪽이 유한한 값이 아닌 경우, &hellip; (생략)</li>
</ol>
<p>(이 또한 재구성한 부분이 있으므로, 정확한 스텝은 실제 스펙을 참고하길 바란다.)</p>
<h3 id="islessthan-알고리즘의-결과"><code>IsLessThan</code> 알고리즘의 결과</h3>
<p>먼저, <code>null</code> 값과 <code>0</code> 값은 이미 원시 타입이므로 변환 과정이 없다.
<a href="https://262.ecma-international.org/13.0/#sec-ecmascript-language-types-null-type">스펙</a>에 따르면, <code>null</code> 값은 Null 타입을 가지며, Null 타입의 유일한 값이다.</p>
<p>이후 수행하는 것은 <code>ToNumeric</code> 알고리즘인데, 내부에서 다시 <code>ToNumber</code> 알고리즘을 수행한다.
이 알고리즘은 숫자 값으로 변환하는 과정을 거치며, <code>null</code> 값은 이때 <code>0</code> 값으로 변환된다.</p>
<p>이제 <code>Number::lessThan(0, 0)</code>을 수행하게 되는데, 이때는 상식적인(?) 비교의 결과를 리턴한다.
즉, <code>0</code>은 <code>0</code>보다 작지 않으므로, <code>false</code> 값을 리턴한다.</p>
<h3 id="null--0-비교의-결과"><code>null &gt;= 0</code> 비교의 결과</h3>
<p>방금 과정은 <code>IsLessThan</code> 알고리즘이었다.<code>&gt;=</code> 연산은 이 알고리즘이 의미하는 바와 반대임을 기억하는가?</p>
<p>실제로 <code>&gt;=</code> 연산은 내부에서 <code>IsLessThan</code> 알고리즘이 <code>false</code>를 리턴할 때, 최종 값은 <code>true</code>를 리턴하도록 되어있다.
따라서 <code>true</code>가 리턴된다.</p>
<h3 id="스펙에서-알-수-있는-점">스펙에서 알 수 있는 점</h3>
<p>알아본 것은 <code>&gt;=</code> 연산이지만, 나머지 비교 연산인 <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code> 연산에도 <code>IsLessThan</code> 알고리즘이 사용된다.
그리고 이 알고리즘에서 첫 번째로 하는 일은 원시 타입으로의 변환이다.</p>
<p>본문에서는 담지 않았지만, <a href="https://262.ecma-international.org/13.0/#sec-isstrictlyequal">스펙</a>에 따르면 <code>===</code> 연산이 갖는 <code>IsStrictlyEqual</code> 알고리즘은, 타입이 다르면 변환 없이 무조건 <code>false</code> 값부터 반환한다.
하지만 <code>&gt;=</code> 비교 연산은 타입이 다를 때 <code>false</code> 값을 반환하기를 기대할 수 없다.</p>
<p>따라서 타입이 다른 두 값을 <code>&gt;=</code> 연산과 같은 것으로 비교할 때, 이것이 과연 의도한 바인가를 다시 생각해봐야 할 수도 있다.</p>
<h2 id="레퍼런스">레퍼런스</h2>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=14jlIxVrcvo">5 Things I Hate about Javascript</a>: 처음에 언급했던, 호기심을 부른 영상이다. 여기서는 다섯 가지의 이상한 점을 얘기하지만, 이 글의 내용은 그 다섯 개에 포함되어 있지 않다.</p>
</li>
<li>
<p>글 작성에 <a href="https://stackoverflow.com/a/13407585">이 SO 답변</a>이 큰 도움이 되었다. 하지만 이 답변은 예전의 ECMA 스펙을 레퍼런스로 쓰고 있다는 점을 감안해야 한다.</p>
</li>
<li>
<p><a href="https://262.ecma-international.org/13.0/">ECMAScript 2022 Spec</a>: 이 글에서 전반적으로 참고한 스펙이다. 매우 긴 내용이므로 페이지 로딩에 시간이 걸릴 수 있다.</p>
</li>
</ul>

    </div>
  </article>

  <div id="comments">
    <script src="https://utteranc.es/client.js" repo="wcho21/hugo-blog-comments" issue-term="pathname" theme="dark-blue" crossorigin="anonymous" async></script>
  </div>

  <ul id="pagination">
    
      <li class="pagination-article">
        <a href="/2022/09/21/javascript-call-apply-bind/">
          <div class="pagination-article-title">
            <span class="pagination-article-title-label">이전 글:</span>
            자바스크립트의 call, apply, bind
          </div>
        </a>
      </li>
    
    
      <li class="pagination-article">
        <a href="/2022/09/25/boostcamp-week-3-retrospective/">
          <div class="pagination-article-title">
            <span class="pagination-article-title-label">다음 글:</span>
            부스트캠프 7기 멤버십 3주차 회고
          </div>
        </a>
      </li>
    
  </ul>

  </main>
  <footer>
    <div id="footer-wrapper">
  <p id="footer-copyright">&copy; 2022 DEVLOG W.</p>
  <p id="footer-contact">wcho.dev@gmail.com</p>
</div>
  </footer>
</body>
</html>